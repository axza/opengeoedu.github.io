---
title: "OpenDataPortal"
output: 
  flexdashboard::flex_dashboard:
    orientation: rows
    #vertical_layout: fill
    logo: oge_logo/icon_scaled.jpg
    favicon: oge_logo/icon_scaled.jpg
    theme: cerulean
    css: css/dashboard.css
  #  source_code: https://github.com/opengeoedu/opengeoedu.github.io
runtime: shiny

  
---



```{r global, include=FALSE}
library(leaflet)
library(flexdashboard)
library(DT)
library(htmltools)
library(crosstalk)
library(rgdal)
library(shiny)
library(shinyjs)
shiny::addResourcePath("icontemp", file.path(getwd(), "icontemp"))
shiny::addResourcePath("out_geodata", file.path(getwd(), "out_geodata"))
shiny::addResourcePath("out", file.path(getwd(), "out"))
shiny::addResourcePath("data", file.path(getwd(), "data"))
#portale <- read.csv("../data/portale_geocoded3.csv")
portale <- read.csv("out_geodata/portale_shifted.csv")

## metadata of column factors, names and colors for spatial range ("Reichweite")
table_meta <- jsonlite::read_json("data/table_meta.json", simplifyVector = TRUE)

portale$Link <- paste0("<a href=\"",htmlEscape(portale$URL),"\" target=\"_blank\">",htmlEscape(portale$Titel),"</a>")

portale$popup <- paste0("<a href=\"",htmlEscape(portale$URL),"\" target=\"_blank\">",htmlEscape(portale$Titel),"</a><br>", htmlEscape(portale$Beschreibung))
portale$Reichweite <- factor(portale$Reichweite, levels=table_meta$reichw, ordered = TRUE)
portale$label = htmlEscape(paste(portale$Titel, "|", portale$Ort))
portale$Typ <- factor(portale$Typ, levels=table_meta$typ, ordered = TRUE)
portale$Typ_names <- portale$Typ
levels(portale$Typ_names) <- table_meta$typ_names

sd <- SharedData$new(portale, group = "portale")
sd_table <- SharedData$new(portale[c("Link","Beschreibung","Ort","Reichweite")], group = "portale")

load("data/auxiliary.RData")
load("data/cities-geonames-deatch.RData")

options(DT.options = list(language = list(url = '//cdn.datatables.net/plug-ins/1.10.15/i18n/German.json', responsive = TRUE,  bPaginate = TRUE, autoWidth = TRUE, scrollX=TRUE)))
source("R/create_map_function.R")

#Column {data-width=650}
#Column {data-width=350}

#Statistik über die eingetragenen Datenportale:
library(rtable)
library(ReporteRs)
#library(flextable)
#blue table (matching the design color)
colorP <- colorRampPalette(colors = c("white","#044e96"))
#gray table
#colorP <- colorRampPalette(colors = c("white","gray"))
tab_colors <- colorP(10)

#selector for country-values that involve multiple values (not one of either austria, swiss or germany)
sel <- which(!(portale$Land %in% c("Deutschland", "Österreich", "Schweiz")))
# create simplified categories for the statistics
Land <- as.character(portale$Land)
Land[sel] <- "länderübergreifend"
Land <- factor(Land, levels = c("Deutschland", "Österreich","Schweiz", "länderübergreifend"), ordered = TRUE)
Typ <- portale$Typ_names
#levels(Typ) <- stringr::str_replace(string = levels(Typ), pattern = "GDI", replacement = "GDI / Geoportal")
ftab <- ftable(data.frame(Typ = Typ, Land = Land, Reichweite = portale$Reichweite))

#statistics per country:
country_stat <- paste0("(",paste(c("DE","AU","CH", "Sonst"),summary(Land), sep = ": ",collapse = ", "),")")

flext <- as.FlexTable(ftab) %>%
  addFooterRow(paste("Datenportale insgesamt:",dim(portale)[1], country_stat), colspan = 6) %>%
  setZebraStyle(even = tab_colors[2], odd = 'white' ) %>%
  setFlexTableBackgroundColors(colors = tab_colors[5],to = c("header")) %>%
  setFlexTableBackgroundColors(colors = tab_colors[5],to = c("footer"))

nfac <- length(levels(Land)) #number of categories for attribute land
#join rows of first column
for(i in seq(1,flext$numrow, by = nfac)){
  flext <- spanFlexTableRows(flext, j = "Typ", i, i+nfac-1 )
}

flext[,1, newpar = TRUE] <- paste0("(",sapply(summary(portale$Typ), function(x) rep(x,4)),")")

flext[,2] <- paste0(" (",as.numeric(rowSums(as.matrix(ftab))),")")



statdoc <- docx() %>%
  addTitle("Übersicht über das Open Data Suchportal", level = 1 ) %>%
  addFlexTable(flext) %>%
  addParagraph("Anzahl der Datenportale im Verzeichnis",stylename = "rTableLegend") %>%
  writeDoc(file="out/verzeichnis_statistik.docx")

m <- createMap(portale,
    table_meta = table_meta,
    clustering = FALSE,
    layerControls = FALSE,
    polygon_fill_color = "#AFBF56",
    polygon_fill_opacity = 0.1)

#-----------------------------------------------------------------------
```


```{r}
tags$div(align="middle", style="text-align:center",
 bscols(widths = c(6,6),
        div(style="display:inline-block; text-align:left",title="Aktivierte Datenfilter sind sowohl auf der Karte als auch in der Tabelle wirksam", filter_checkbox("bezug_portal", "Portal-Typ", sd, ~Typ_names, inline = FALSE, allLevels = TRUE)),
        div(style="display:inline-block; text-align:left",title="Aktivierte Datenfilter sind sowohl auf der Karte als auch in der Tabelle wirksam", filter_checkbox("bezug_check", "Reichweite", sd, ~Reichweite, inline = FALSE))
   )
 )

# tags$div(align="middle", style="text-align:center",
#  bscols(widths = c(6,6),
#         div(style="display:inline-block; text-align:left",title="Aktivierte Datenfilter sind sowohl auf der Karte als auch in der Tabelle wirksam", filter_checkbox("bezug_portal2", "Portal-Art", sd, ~Typ, inline = TRUE)),
#         div(style="display:inline-block; text-align:left",title="Aktivierte Datenfilter sind sowohl auf der Karte als auch in der Tabelle wirksam", filter_checkbox("bezug_check2", "Räumlicher Bezug", sd, ~Bezug, inline = TRUE))
#    )
#  )
```

#Row {.tabset .tabset-fade}
-----------------------------------------------------------------------


### Karte 

```{r, fig.height=8}
portalMapUI <- function(id) {
  ns <- NS(id)
  tagList(leafletOutput(ns("map")))
}

#m <- NULL

#withProgress(message = "Karte wird geladen...", expr ={
#  m <<- createMap(portale, clustering = FALSE, layerControls=FALSE)
#    setProgress(value = 1)
#})


# Server function
portalMap <- function(input, output, session) {
  output$map <- renderLeaflet({
    withProgress(message = "Karte wird geladen...", expr = {
      isolate({
      setProgress(value = 1)
      m
      })
    })
  })
  # output$map <- renderLeaflet({
  #   withProgress(message = "Karte wird geladen...", expr = {
  #   isolate({
  #   m <<- createMap(portale,
  #   clustering = FALSE,
  #   layerControls = FALSE)
  #   })
  #   setProgress(value = 1)
  #   m
  #   })
  # })
  
  observe({
   if(length(input$map_zoom) == 1){
     proxy <- leafletProxy("map")
    if(input$map_zoom >= 9){
      proxy %>% showGroup("adm6_labels")  
    }else if(input$map_zoom < 9){
      proxy %>% hideGroup("adm6_labels")  
     }
     
    if(input$map_zoom >= 8){
      
      proxy %>% hideGroup("portals") %>%
             showGroup("adm5") %>%
             showGroup("adm6") %>%
             showGroup("portals")
    }else if(input$map_zoom < 8){
      proxy %>% hideGroup("adm5") %>%
          hideGroup("adm6")
     }
    if(input$map_zoom >= 7){
      proxy %>% hideGroup("portals") %>%
            showGroup("adm4_labels")  %>%
            showGroup("portals")
    }
     if(input$map_zoom < 7){
      proxy %>%  hideGroup("portals") %>%
         hideGroup("adm4_labels")  %>%
          showGroup("portals")
    }}
    
  })
}

# call the module
portalMapUI("oge")
callModule(portalMap, "oge")

```


### Tabelle

```{r fig.height=8}
#DT::datatable(portale[c("Link","Beschreibung","Ort","Land","Bezug", "Lizenz")], escape = FALSE, options = list(
#  bPaginate = TRUE
#))
#data(iris)
#DT::datatable(iris, escape = FALSE, extensions = "Responsive")

#DT::datatable(data.frame(blablabla = 1:4, blablabla2 = 1:4, blablub = 1:4), escape = FALSE, extensions = c("Responsive"))

div(class="metawrapper", style="height:100%",
#div(style="height:100%",
DT::datatable(sd_table, escape = FALSE, extensions = c("Responsive"), options = list(columnDefs= list(list(responsivePriority= 12000, targets=2))))
)
#)




```


### Metadaten

Die dargestellten Geodaten zu den Open Data Portalen und GDIs in Deutschland, Österreich und Schweiz können in verschiedenen Dateiformaten heruntergeladen werden. Beachten Sie, dass die Koordinaten sich überlappender Punkte zwecks besserer Darstellung leicht verschoben wurden. Alle Koordinaten sind in Längen- und Breitengraden angegeben (Tabellenspalten mit Namen "lon" und "lat") und beziehen sich auf das Datum WGS84.

* [CSV Tabelle](out_geodata/portale_shifted.csv)
* [geojson](out_geodata/portale_shifted.geojson)
* [GeoPackage](out_geodata/portale_shifted.gpkg)
* [Geography Markup Language (GML)](out_geodata/portale_shifted.gml)
* [Keyhole Markup Language (KML)](out_geodata/portale_shifted.kml)
* [ESRI Shapefile (ZIP-Archiv)](out_geodata/portale_shifted-ESRI-Shapefile.zip)

Die geokodierten Rohdaten (mit überlappenden Koordinaten) sind als CSV-Tabelle verfügbar:

* [Rohdaten (CSV Tabelle)](data/portale_geocoded3.csv)

### Statistik

Die nachfolgende Tabelle gibt einen Überblick über die gegenwärtig eingetragenen Datenportale und ist von links nach rechts zu lesen. Die linke Spalte gibt die Anzahl der Einträge nach Typ des Portales (Open Data Portal oder GDI-Knotenpunkt bzw. Geoportal) an. Die Spalte rechts daneben gibt, nach Portal-Typ aufgeschlüsselt, das Land an, in welchem das Portal bzw. der Herausgeber der Inhalte verortet ist. In einigen Fällen beteiligen sich mehrere Länder an einem Portal (Beispiel: [GeoRhena](http://www.georhena.eu/), ein deutsch/französisch/schweizer Projekt zur Erfassung der Oberrhein-Region). Diese Portale sind hier als *länderübergreifend* kategorisiert. Die rechten vier Spalten schlüsseln die Portale nach ihrer Reichweite, spezifisch für jedes Land und jede Portal-Art, auf. Dabei halten kommunale Portale Daten über einzelne Kommunen, Landkreise oder Städte bereit. Regionale Portale beziehen sich auf einzelne Regionen oder Bundesländer. Nationale Portale halten für ein bestimmtes Land umfassende Daten bereit. Internationale Portale führen Daten über mehrere Länder, Kontinente oder weltweite Datensätze.

```{r echo=FALSE, tidy=TRUE}
tags$div(class = "statwrapper", renderFlexTable(flext))
#flext
#renderFlexTable(flext)
```

### Neuer Eintrag / Korrektur beantragen

```{r}
outputDir <- "data/user_input"

saveData <- function(data) {
  if(!dir.exists(outputDir)){
    dir.create(outputDir)
  }
  data <- t(data)
  # Create a unique file name
  fileName <- sprintf("Edits_%s_%s.csv", as.integer(Sys.time()), digest::digest(data))
  # Write the file to the local system
  write.csv(
    x = data,
    file = file.path(outputDir, fileName), 
    row.names = FALSE, quote = TRUE
  )
}

loadData <- function() {
  # Read all the files into a list
  files <- list.files(outputDir, full.names = TRUE)
  files <- files[stringr::str_detect(files,"\\.csv$")]
  if(length(files)==0)
    return(NULL)
  data <- lapply(files, read.csv, stringsAsFactors = FALSE) 
  # Concatenate all data together into one data.frame
  data <- do.call(rbind, data)
  data
}

shinyApp(
  ui = fluidPage(
      shinyjs::useShinyjs(),
      id = "submit-form",
      numericInput("ID", label = "ID (bei vorhandenen Einträgen)", min = 1, max = dim(portale)[1], value = NA_integer_, step = 1),
      
      textInput("Titel", label = "Titel", placeholder = "Titel der Website"),
      
      textInput("URL", label = "URL", placeholder = "https://www.beispiel.de"),
      textAreaInput("Beschreibung", label = "Beschreibung", placeholder = "Kurze Beschreibung des Open Data Portals oder der GDI", width = "400px",   height = "100px"),
      
      radioButtons("Typ", "Art des Portals:",
          choiceNames = 
            table_meta$typ_names, 
          choiceValues = 
            table_meta$typ,
          inline = TRUE,
      ),
      
      textInput("Ort", label = "Ort (Bezug des Portals)", placeholder = "Gemeinde, Land oder Region"),
      
      radioButtons("Reichweite", "Reichweite:",
          choices =
             table_meta$reichw, inline = TRUE,
      ),
      
      
      textInput("Adresse_Herausgeber", label = "Adresse des Herausgebers oder Koordinaten zur Geolokalisierung des Portals", placeholder = "52.5161 N, 13.3777 E / Pariser Platz, 10117 Berlin", width = "400px"),
      
      radioButtons("Oeffentlich", "Staatlich / Öffentlich",
          choiceNames =
            table_meta$staatl,
          choiceValues =
            table_meta$staatl, inline = TRUE,
      ), title = "Portal eintragen / editieren",
      
       textInput("Autor", label = "Kontakt (Optional)", placeholder = "Ihr Name / E-Mail"),
      tags$head(
            tags$style(HTML('#submit{background-color:#044D94; color: white;} #submit:hover{background-color:#e7e7e7; color: black;} '))
      ),
      actionButton("submit","Anfrage senden"),  actionButton("reset","Formular zurücksetzen"),
      tags$hr(),
      "Offene Anfragen:"
      ,DT::dataTableOutput("responses") 
  
  ),
  server = function(input, output, session){
    observe({
      id <- input$ID
        if(!is.na(id) && is.numeric(id)){
          updateTextInput(session, inputId = "Titel", value = portale$Titel[id])
          updateTextInput(session, inputId = "URL", value = portale$URL[id])
          updateRadioButtons(session, inputId = "Typ", selected = portale$Typ[id])
          updateTextAreaInput(session, inputId = "Beschreibung", value = portale$Beschreibung[id])
          updateRadioButtons(session, inputId = "Reichweite", selected = portale$Reichweite[id])
          
          coords <- paste0(portale[id,"lat"]," N, ", portale[id,"lon"]," E ")
          
          updateTextInput(session, inputId = "Adresse_Herausgeber", value = coords)
          updateTextInput(session, inputId = "Ort", value = portale$Ort[id])
          updateRadioButtons(session, inputId = "Oeffentlich", selected = portale$Staatlich_Öffentlich[id])
        }
    })
    
      # Whenever a field is filled, aggregate all form data
    formData <- reactive({
      data <- sapply(c("Titel","URL","Typ","Beschreibung","Reichweite", "Adresse_Herausgeber", "Ort", "Oeffentlich", "Autor"), function(x) input[[x]])
      data
    })
    
    # When the Submit button is clicked, save the form data
    observeEvent(input$submit, {
      saveData(formData())
      shinyjs::alert("Vielen Dank!\nIhre Anfrage wurde gesendet und wird bald bearbeitet.")
      shinyjs::reset("submit-form")
      output$responses <- DT::renderDataTable({
        input$submit
        loadData()
    }, extensions = "Responsive")   
    })
    
    observeEvent(input$reset, {
      shinyjs::reset("submit-form")
    })
    
    # Show the previous responses
    # (update with current response when Submit is clicked)
  output$responses <- DT::renderDataTable({
      input$submit
     loadData()
   }, extensions = "Responsive")    
    
  }
)

```

Row {data-height=20 color="white"}
-----------------------------------------------------------------------
© 2017. All rights reserved &nbsp;|&nbsp; [Impressum](https://www.auf.uni-rostock.de/footer/impressum/){target="_blank"} &nbsp; | &nbsp; [Source Code](https://github.com/opengeoedu/opengeoedu.github.io/){target="_blank"} &nbsp; | &nbsp;
 <a href="javascript:void(0)" onclick="document.getElementById('section-light').style.display='block';document.getElementById('section-fade').style.display='block'">Quellenhinweise</a> 
<div id="light" class="white_content"><p align=right><a href="javascript:void(0)" onclick="document.getElementById('section-light').style.display='none';document.getElementById('section-fade').style.display='none'">X Fenster schließen</a></p>
  <span align="left">
  <h1>Quellenhinweise</h1>
  Diese Übersicht beruht auf folgenden externen Datenquellen:

* **Ortsnamen und Beschriftungen (Städte):** <a href="http://www.geonames.org/export/">GeoNames Data</a>, lizensiert unter <a href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 License</a>
* **Verwaltungsgebiete (DE, AT, CH):** [OpenStreetMap](http://www.openstreetmap.org/copyright) contributors, lizensiert unter [Open Database License](https://opendatacommons.org/licenses/odbl/)
* **Geocoding Service (einmalige Geolokalisierung einzelner Portale):** [Nomanitim](https://operations.osmfoundation.org/policies/nominatim/)
* **Grundkarte:** Positron von [CartoDB](https://carto.com/attribution/), abgeleitet von [OpenStreetMap](http://www.openstreetmap.org/copyright) Daten
</span>

  </div><div id="fade" class="black_overlay"></div> &nbsp;|&nbsp; 
  [OpenGeoEdu Website](http://www.opengeoedu.de/){target="_blank"}
  
<script>
document.title = "OpenDataPortal: Öffentliche Datenportale im Deutschland, Österreich und der Schweiz";
document.body.style.background = "#E3EBF3";

changeFun = function(value, obj){
 // alert('Changed value of '+value+" to "+obj.checked);
  /* var checkboxes = document.getElementsByTagName("input");
  for (var i = 0; i < checkboxes.length; i++) {
      var checkbox = checkboxes[i];
      if(checkbox.value == value && checkbox.checked != obj.checked) {
        checkbox.checked = obj.checked;
      }
   }*/

var x = document.getElementsByClassName("crosstalk-input-checkboxgroup");
  for (var j = 0; j < x.length; j++) {
    var checkboxes = x[j].getElementsByTagName("input");
     var noneselected = true;
    for (var i = 0; i < checkboxes.length; i++) {
      var checkbox = checkboxes[i];
       //checkbox.parentNode.className = (checkbox.parentNode.className + " noneselected").trim();
      if(checkbox.value == value && checkbox.checked != obj.checked) {
        checkbox.checked = obj.checked;
        noneselected = noneselected && !(checkbox.checked);
      }

    }
    /*for (var i = 0; i < checkboxes.length; i++) {
      var checkbox = checkboxes[i];
      if(noneselected){
        //alert("noneselected!");
        checkbox.parentElement.className = (checkbox.parentElement.className + " noneselected").trim();
      } else {
        checkbox.parentElement.className = checkbox.parentElement.className.replace("noneselected","").trim();
      }
    }*/
  
  }
/*
var x = document.getElementsByClassName("crosstalk-input-checkboxgroup");
  for (var j = 0; j < x.length; j++) {
   // var noneselected = true;
    var checkboxes = x[j].getElementsByTagName("input");
    for (var i = 0; i < checkboxes.length; i++) {
      var checkbox = checkboxes[i];
      if(checkbox.value == value && checkbox.checked != obj.checked) {
        checkbox.checked = obj.checked;
      }
     // noneselected = noneselected && !(checkbox.checked);

    }

    /* for (var i = 0; i < checkboxes.length; i++) {
      if(noneselected){
        alert("noneselected!");
        checkbox[i].parentElement.className = (checkbox[i].parentElement.className + " noneselected").trim();
      } else {
        checkbox[i].parentElement.className = checkbox[i].parentElement.className.replace("noneselected","").trim();
      }
    }
  }*/

}

var x = document.getElementsByClassName("crosstalk-input-checkboxgroup");
var i;
for (i = 0; i < x.length; i++) {
    var inputs = x[i].getElementsByTagName("input");
    for (var j = 0; j < inputs.length; j++) {
      input = inputs[j];
      input.className = "crosstalk_checkbox";
      input.nextElementSibling.className = "checkbox_label";
      var parent = input.parentNode;
      parent.className = (parent.className + " checkbox_container").trim();
      var checkmark = document.createElement('span');
      checkmark.className = "checkmark";
      // set element as child of input
      parent.insertBefore(checkmark, input.nextSibling);

   //  input.checked = true;
      input.setAttribute("onchange", "changeFun('"+input.getAttribute("value")+"', this)");
    }
}
 </script>